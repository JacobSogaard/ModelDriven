/*
 * generated by Xtext 2.21.0
 */
package org.xtext.example.mydsl.generator

import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.myMath.Add
import org.xtext.example.mydsl.myMath.Div
import org.xtext.example.mydsl.myMath.MathExp
import org.xtext.example.mydsl.myMath.Mult
import org.xtext.example.mydsl.myMath.Num
import org.xtext.example.mydsl.myMath.Sub
import org.xtext.example.mydsl.myMath.Expression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyMathGenerator extends AbstractGenerator {
	
override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		System.out.println("Math expression = "+math.display)
		// For +1 score, replace with hovering, see Bettini Chapter 8
		JOptionPane.showMessageDialog(null, "result = "+result,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def int compute(MathExp math) { 
		math.getExp().computeExpression
	}
	
	def int computeExpression(Expression exp) {
		switch exp {
			Add: exp.left.computeExpression + exp.right.computeExpression
			Sub: exp.left.computeExpression-exp.right.computeExpression
			Mult: exp.left.computeExpression*exp.right.computeExpression
			Div: exp.left.computeExpression/exp.right.computeExpression
			Num: exp.value
			default: 1
		}
	}


	//
	// Display function: show complete syntax tree
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	def int display(MathExp math){
		math.exp.displayExp
	}
	
	def int displayExp(Expression exp){
		switch exp{
			Add: exp.left.computeExpression()+exp.right.computeExpression
			Sub: exp.left.computeExpression()-exp.right.computeExpression
			Mult: exp.left.computeExpression()*exp.right.computeExpression
			Div: exp.left.computeExpression()/exp.right.computeExpression
			Num: exp.value
			default: throw new Error("Invalid!")
		}
	}

}
